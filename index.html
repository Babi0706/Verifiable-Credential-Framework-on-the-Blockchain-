<script>
  let provider, signer, contract;

  const contractAddress = "0x253B1283b1019784fE2E8126B33BEC5571144d63";
  const contractABI = [
    {
      "inputs": [{ "internalType": "bytes32", "name": "certHash", "type": "bytes32" }],
      "name": "issueCertificate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "bytes32", "name": "certHash", "type": "bytes32" }],
      "name": "revokeCertificate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [{ "internalType": "bytes32", "name": "certHash", "type": "bytes32" }],
      "name": "verifyCertificate",
      "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
      "stateMutability": "view",
      "type": "function"
    }
  ];

  async function connectWallet() {
    if (typeof window.ethereum !== "undefined") {
      try {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        contract = new ethers.Contract(contractAddress, contractABI, signer);
        const address = await signer.getAddress();
        document.getElementById("status").innerText = `‚úÖ Connected: ${address}`;
      } catch (error) {
        console.error("Connection Error:", error);
        document.getElementById("status").innerText = "‚ùå Failed to connect to MetaMask.";
      }
    } else {
      alert("ü¶ä MetaMask not detected! Please install MetaMask.");
    }
  }

  async function generateHashFromPDF() {
    const fileInput = document.getElementById("pdfInput");
    const file = fileInput.files[0];
    if (!file) return alert("Please upload a PDF file.");

    const reader = new FileReader();
    reader.onload = function(event) {
      const arrayBuffer = event.target.result;
      const bytes = new Uint8Array(arrayBuffer);
      const hash = ethers.utils.keccak256(bytes);
      document.getElementById("certHash").value = hash;
    };
    reader.readAsArrayBuffer(file);
  }

  async function issueCert() {
    if (!contract) return alert("Please connect wallet first.");
    const hash = document.getElementById("certHash").value;
    if (!hash) return alert("Generate or enter certificate hash first.");

    try {
      const hashBytes32 = ethers.utils.arrayify(hash); // ‚úÖ FIXED
      const tx = await contract.issueCertificate(hashBytes32);
      await tx.wait();
      document.getElementById("status").innerText = "‚úÖ Certificate issued.";
    } catch (err) {
      console.error(err);
      document.getElementById("status").innerText = "‚ùå Error issuing certificate.";
    }
  }

  async function revokeCert() {
    if (!contract) return alert("Please connect wallet first.");
    const hash = document.getElementById("certHash").value;
    if (!hash) return alert("Generate or enter certificate hash first.");

    try {
      const hashBytes32 = ethers.utils.arrayify(hash); // ‚úÖ FIXED
      const tx = await contract.revokeCertificate(hashBytes32);
      await tx.wait();
      document.getElementById("status").innerText = "‚ö†Ô∏è Certificate revoked.";
    } catch (err) {
      console.error(err);
      document.getElementById("status").innerText = "‚ùå Error revoking certificate.";
    }
  }

  async function verifyCert() {
    if (!contract) return alert("Please connect wallet first.");
    const hash = document.getElementById("certHash").value;
    if (!hash) return alert("Generate or enter certificate hash first.");

    try {
      const hashBytes32 = ethers.utils.arrayify(hash); // ‚úÖ FIXED
      const isValid = await contract.verifyCertificate(hashBytes32);
      document.getElementById("status").innerText = isValid
        ? "‚úÖ Certificate is VALID."
        : "‚ùå Certificate is INVALID or REVOKED.";
    } catch (err) {
      console.error(err);
      document.getElementById("status").innerText = "‚ùå Error verifying certificate.";
    }
  }
</script>
